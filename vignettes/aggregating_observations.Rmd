---
title: "Aggregating some observations in a data frame"
author: "Marc Choisy"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

A common task when working on spatio-temporal data frames is aggregating the
observations of some variables, either in space, or in time. This can be done
easilty with the `aggregate_by` function of the `dplyrx` package. Let's load it:

```{r}
library(dplyrx)
```

To understand it better what the function can help do let's have a  look at the
following meteorological data from the `dplyrx` package:

```{r meteo_data}
data(meteo)
meteo
```

This data set contains the values of temperature (Â°C), absolute humidity
(g / m$^3$), rainfall (mm) and hours of sunshine from 3 meteorological stations
(Can Tho, Da Lat and Da Nang) for the months of January, May and September in
2013, 2014 and 2015. From here, imagine that you want to aggretate all the
observations of the stations Can Tho and Da Lat. An obvious way to do so is
probably to take the mean. This can be done so with the `aggregate_by` function
of the `dplyrx` package:

```{r}
aggregate_by(meteo, station %in% c("Can Tho", "Da Lat"), month, year, fun = mean)
```

The fact that we want to aggregate the observations of the stations Can Tho and
Da Lat is specified by the second argument `station %in% c("Can Tho", "Da Lat")`.
Note that this can be specified in any way that can be recognized by the
`dplyr::filter` function. For example,

```{r eval = FALSE}
aggregate_by(meteo, grepl("Can|Lat", station), month, year, fun = mean)
```

would have worked just as well. Then, after, the second argument are listed all
the variables that should be used to identify unique observations to aggregate
in each of the stations Can Tho and Da Lat. Here we want aggregate by space but
keep the temporal information contained in the variables `month` and `year`. The
last argument, `fun` specifies the function that should be used to perform the
aggregation. By default it's `sum` but here it makes more sense to do `mean`. To
finish, let's talk about the last argument of the function, `new_name`, that we
haven't used in the previous calls. By default, the new value of the `station`
variable for the aggregated observations is `Can Tho & Da Lat`, i.e. the names
of the 2 aggregated stations separated by `&`. This default behavior can be
overwriten by explicitly specifying the `new_name` argument, for example:

```{r}
aggregate_by(meteo, station %in% c("Can Tho", "Da Lat"), month, year, fun = mean, new_name = "mean of CT and DL")
```

