---
title: "Aggregating some observations in a data frame"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

A common task when working on spatio-temporal data frames is aggregating the
observations of some variables, either in space, or in time. This can be done
easilty with the `aggregate_by` function of the `dplyrx` package. Let's load it:

```{r}
library(dplyrx)
```

To understand it better what the function can help do let's have a  look at the
following meteorological data from the `dplyrx` package:

```{r meteo_data}
data(meteo)
meteo
```

This data set contains the values of temperature (Â°C), absolute humidity
(g / m$^3$), rainfall (mm) and hours of sunshine from 3 meteorological stations
(Can Tho, Da Lat and Da Nang) for the months of January, May and September in
2013, 2014 and 2015. From here, imagine that you want to aggretate all the
observations of the stations Can Tho and Da Lat. An obvious way to do so is
probably to take the mean. This can be done so with the `aggregate_by` function
of the `dplyrx` package:

```{r}
aggregate_by(meteo, station %in% c("Can Tho", "Da Lat"), month, year, fun = mean)
```

The fact that we want to aggregate the observations of the stations Can Tho and
Da Lat is specified by the second argument `station %in% c("Can Tho", "Da Lat")`.
Note that this can be specified in any way that can be recognized by the
`dplyr::filter` function. For example,

```{r eval = FALSE}
aggregate_by(meteo, grepl("Can|Lat", station), month, year, fun = mean)
```

would have worked just as well. Then, after, the second argument are listed all
the variables that should be used to identify unique observations to aggregate
in each of the stations Can Tho and Da Lat. Here we want aggregate by space but
keep the temporal information contained in the variables `month` and `year`. The
last argument, `fun` specifies the function that should be used to perform the
aggregation. By default it's `sum` but here it makes more sense to do `mean`.
Let's now talk about the last argument of the function, `new_name`, that we
haven't used in the previous calls. By default, the new value of the `station`
variable for the aggregated observations is `Can Tho & Da Lat`, i.e. the names
of the 2 aggregated stations separated by `&`. This default behavior can be
overwriten by explicitly specifying the `new_name` argument, for example:

```{r}
aggregate_by(meteo, station %in% c("Can Tho", "Da Lat"), month, year, fun = mean, new_name = "mean of CT and DL")
```

We can naturally aggregate the observations of more than 2 provinces. For
example, let's consider `temperature` and `humidity` only and average their
values of the stations of Can Tho, Da Lat and Da Nang:

```{r}
meteo %>%
  select(-rainfall, -sunshine) %>% 
  aggregate_by(grepl("Can|Da", station), month, year, fun = mean)
```

## A more complex situation

Let's now consider the case where, with the `meteo` data set, instead of
performing a spatial aggregation we want to  perform a temporal aggregation.
Let's imagine for example that we want to aggregate the months of January and
May for all the provinces. What's apparent here is that the proper way of
performing such an aggregation for the variables `temperature` and `humidity`
would probably to use the `mean` function whereas it would certainly make more
sense to use the `sum` function for the variables `rainfall` and `sunshine`. The
pipeline below shows how to do so. First we need to define an utilitary function
that add flexibility on the `aggregate_by` call to the `meteo` data frame.
Specifically, it allows to define the variables of `meteo` we want to consider,
and the function `f` we want to use as the `fun` argument of the `aggregate_by`
function:

```{r}
fct <- function(x, f) {
  aggregate_by(meteo[, !grepl(paste(x, collapse = "|"), names(meteo))],
               month %in% c("January", "May"), year, station, fun = f)
}
```

Then, using this utilitary function `fct` together with the `map2` and `invoke`
functions of the `purrr` package we can get the targetted output:

```{r}
library(purrr)
map2(list(c("rain", "sun"), c("temp", "hum")), c(mean, sum), fct) %>% 
  invoke(left_join, ., by = c("year", "month", "station"))
```

