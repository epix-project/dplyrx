---
title: "Aggregating some observations in a data frame"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

A common task when working on spatio-temporal data frames is aggregating the
observations of some variables, either in space, or in time. This can be done
easilty with the `aggregate_by` function of the `dplyrx` package. Let's load it:

```{r}
library(dplyrx)
```

To understand it better what the function can help do let's have a  look at the
following meteorological data from the `dplyrx` package:

```{r meteo_data}
data(meteo)
meteo
```

This data set contains the values of temperature (Â°C), absolute humidity
(g / m$^3$), rainfall (mm) and hours of sunshine from 3 meteorological stations
(Can Tho, Da Lat and Da Nang) for the months of January, May and September in
2013, 2014 and 2015. From here, imagine that you want to aggretate all the
observations of the stations Can Tho and Da Lat. An obvious way to do so is
probably to take the mean. This can be done so with the `aggregate_by` function
of the `dplyrx` package:

```{r}
aggregate_by(meteo, station, month, year, expr = . %in% c("Can Tho", "Da Lat"), fun = mean)
```

The fact that we want to aggregate the observations of the stations Can Tho and
Da Lat is specified by the `expr` argument `. %in% c("Can Tho", "Da Lat")`.
Where `station` is replace by a dot.
Note that this can be specified in any way that can be recognized by the
`dplyr::filter` function. For example,

```{r eval = FALSE}
aggregate_by(meteo, station, month, year, expr = grepl("Can|Lat", .), fun = mean)
```

would have worked just as well. Then, after, the third argument are listed all
the variables that should be used to identify unique observations to aggregate
in each of the stations Can Tho and Da Lat. Here we want aggregate by space but
keep the temporal information contained in the variables `month` and `year`. The
last argument, `fun` specifies the function that should be used to perform the
aggregation. By default it's `sum` but here it makes more sense to do `mean`.
Let's now talk about the last argument of the function, `new_name`, that we
haven't used in the previous calls. By default, the new value of the `station`
variable for the aggregated observations is `Can Tho & Da Lat`, i.e. the names
of the 2 aggregated stations separated by `&`. This default behavior can be
overwriten by explicitly specifying the `new_name` argument, for example:

```{r}
aggregate_by(meteo, station, month, year, expr = . %in% c("Can Tho", "Da Lat"), fun = mean, new_name = "mean of CT and DL")
```

We can naturally aggregate the observations of more than 2 provinces. For
example, let's consider `temperature` and `humidity` only and average their
values of the stations of Can Tho, Da Lat and Da Nang:

```{r}
meteo %>%
  select(-rainfall, -sunshine) %>% 
  aggregate_by(station, month, year, expr = grepl("Can|Da", .), fun = mean)
```

## A more complex situation

Let's now consider the case where, with the `meteo` data set, instead of
performing a spatial aggregation we want to  perform a temporal aggregation.
Let's imagine for example that we want to aggregate the months of January and
May for all the provinces. What's apparent here is that the proper way of
performing such an aggregation for the variables `temperature` and `humidity`
would probably to use the `mean` function whereas it would certainly make more
sense to use the `sum` function for the variables `rainfall` and `sunshine`. The
pipeline below shows how to do so. First we need to define an utilitary function
that add flexibility on the `aggregate_by` call to the `meteo` data frame.
Specifically, it allows to define the variables of `meteo` we want to consider,
and the function `f` we want to use as the `fun` argument of the `aggregate_by`
function:

```{r}
fct <- function(x, f) {
  aggregate_by(meteo[, !grepl(paste(x, collapse = "|"), names(meteo))],
               month, year, station, expr = .  %in% c("January", "May"), fun = f)
}
```

Then, using this utilitary function `fct` together with the `map2` and `invoke`
functions of the `purrr` package we can get the targetted output:

```{r}
library(purrr)
map2(list(c("rain", "sun"), c("temp", "hum")), c(mean, sum), fct) %>% 
  invoke(left_join, ., by = c("year", "month", "station"))
```

## Programming with aggregate_by

The function `aggregate_by` has been written to make it possible to program 
with. Let's consider a case where we want to perform a serie of spatial 
aggregation. For example, we can imagine that the station where previously 
regroup in group. Let's imahine that the `group C` was form with `Da Nang` and 
`Da Lat`) before in a `Group B` (`Group C`, `Can Tho`) et even before all the 
station were in one group called `Group A`. We can create a function doing a 
serie of spatial aggregation. 

First, we need a list indicating all the event: 

```{r}
event_lst <- list("2014" = list(before = c("Group C") , after = c("Da Nang", "Da Lat")),
                  "2013" = list(before = c("Group B") , after = c("Can Tho", "Group C")),
                  "2012" = list(before = c("Group A") , after = c("Sa Pa", "Group B")))

```

We can, now, write a function using the list of event to recreate the
group of station. The function selects one event after the other and aggregate
the station indicate in the slot `after` of our list of event, and rename the 
results with the slop `before`. For more flexibility, we also add the parameter 
`col_group_by` corresponding to the parameter `...` of the `aggregate_by` 
function.

```{r}
merge_province <- function(df, event_lst, col_group_by){
  for (i in seq_along(event_lst)) {
    # select one event
    event <- event_lst[[i]]
    # prepare the expression
      expr = event$after %>% unlist %>% as.vector %>% 
        paste(collapse = "', '") %>% paste0(". %in% c('" , ., "')")
      # call aggregate_by
      df %<>%  aggregate_by(station, col_group_by, expr = expr, 
                                 new_name = event$before %>% unlist)
  }
  df 
}

```

We can now, apply our function with all the grouping event, 

```{r}
merge_province(meteo, event_lst, c("month", "year"))
```

or just a selection of event: 

```{r}
merge_province(meteo, event_lst[c("2014", "2013")], c("month", "year"))
```

We can also, use the `col_group_by` parameters to have the result by year 
instead of month and year. We just need to remove the column `month` of the 
data frame inputed.

```{r}
merge_province(select(meteo, -month), event_lst, "year")
```
